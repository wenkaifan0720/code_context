import 'context_builder.dart';

// Re-export LLM components for convenience
export 'llm/llm_service.dart';
export 'llm/anthropic_service.dart';
export 'llm/doc_tools.dart';
export 'llm/doc_agent.dart';

/// A generated documentation result.
class GeneratedDoc {
  const GeneratedDoc({
    required this.content,
    required this.smartSymbols,
    this.title,
    this.summary,
  });

  /// The full markdown content.
  final String content;

  /// Smart symbols (scip:// URIs) referenced in the doc.
  final List<String> smartSymbols;

  /// Optional extracted title.
  final String? title;

  /// Optional extracted summary.
  final String? summary;
}

/// Abstract interface for documentation generation.
///
/// Implementations can use different LLM providers (Anthropic, OpenAI, etc.)
/// or stub implementations for testing.
abstract class DocGenerator {
  /// Generate documentation for a folder.
  ///
  /// The [context] contains full folder info plus dependency summaries.
  /// For folders with subfolders, the agent should use `read_subfolder_doc`
  /// to read child docs and synthesize a higher-level overview.
  Future<GeneratedDoc> generateFolderDoc(DocContext context);
}

/// Stub implementation that generates placeholder documentation.
///
/// Useful for testing the pipeline without actual LLM calls.
class StubDocGenerator implements DocGenerator {
  const StubDocGenerator();

  @override
  Future<GeneratedDoc> generateFolderDoc(DocContext context) async {
    final buffer = StringBuffer();
    final smartSymbols = <String>[];

    // Title from folder name
    final folderName = context.current.path.split('/').last;
    final title = _toTitleCase(folderName);
    buffer.writeln('# $title');
    buffer.writeln();

    // Overview section
    buffer.writeln('## Overview');
    buffer.writeln();
    buffer.writeln(
        '> This documentation was generated by the stub generator. '
        'Replace with actual LLM-generated content.');
    buffer.writeln();

    // Files section
    buffer.writeln('## Files');
    buffer.writeln();
    for (final file in context.current.files) {
      final fileName = file.path.split('/').last;
      buffer.writeln('- `$fileName`');
      for (final api in file.publicApi) {
        buffer.writeln('  - ${api.kind} [`${api.name}`][${_toAnchor(api.name)}]');
        
        // Build scip:// URI for smart symbol
        final uri = 'scip://${file.path}/${api.name}#';
        smartSymbols.add(uri);
      }
    }
    buffer.writeln();

    // Dependencies section
    if (context.internalDeps.isNotEmpty || context.externalDeps.isNotEmpty) {
      buffer.writeln('## Dependencies');
      buffer.writeln();

      if (context.internalDeps.isNotEmpty) {
        buffer.writeln('### Internal');
        for (final dep in context.internalDeps) {
          buffer.writeln('- `${dep.path}`');
          for (final sym in dep.usedSymbols) {
            buffer.writeln('  - $sym');
          }
        }
        buffer.writeln();
      }

      if (context.externalDeps.isNotEmpty) {
        buffer.writeln('### External Packages');
        for (final dep in context.externalDeps) {
          buffer.writeln('- `${dep.name}`');
          for (final sym in dep.usedSymbols) {
            buffer.writeln('  - $sym');
          }
        }
        buffer.writeln();
      }
    }

    // Smart symbol definitions
    buffer.writeln('<!-- Smart Symbol Definitions -->');
    for (final file in context.current.files) {
      for (final api in file.publicApi) {
        buffer.writeln('[${_toAnchor(api.name)}]: scip://${file.path}/${api.name}#');
      }
    }

    final summary = 'Documentation for ${context.current.path} folder.';

    return GeneratedDoc(
      content: buffer.toString(),
      smartSymbols: smartSymbols,
      title: title,
      summary: summary,
    );
  }

  /// Convert snake_case or kebab-case to Title Case.
  String _toTitleCase(String s) {
    return s
        .replaceAll('_', ' ')
        .replaceAll('-', ' ')
        .split(' ')
        .map((word) {
          if (word.isEmpty) return word;
          return word[0].toUpperCase() + word.substring(1).toLowerCase();
        })
        .join(' ');
  }

  /// Convert a name to a markdown anchor.
  String _toAnchor(String name) {
    return name.toLowerCase().replaceAll(RegExp(r'[^a-z0-9]'), '-');
  }
}
